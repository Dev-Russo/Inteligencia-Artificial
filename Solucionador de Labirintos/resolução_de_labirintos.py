# -*- coding: utf-8 -*-
"""Resolução de Labirintos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TWiDghTigFjtz-xmpa4Igw1DqGO3Yija
"""

import matplotlib.pyplot as plt
from heapq import heappush, heappop

# Labirinto (1 = parede, 0 = livre)
grid = [
    [1,1,0,1,1,1,1,0],
    [0,0,0,0,0,0,1,0],
    [0,1,1,1,0,1,1,0],
    [0,1,1,1,0,0,0,0],
    [0,1,0,1,0,1,0,1],
    [0,1,0,1,0,1,0,0],
    [0,1,0,1,0,1,1,0],
    [0,0,0,0,0,0,0,0],
]

start = (7,0)
goal = (0,7)
rows = len(grid)
cols = len(grid[0])

# Distância Manhattan
def manhattan(a,b):
    return abs(a[0]-b[0])+abs(a[1]-b[1])

# Movimentos (direita, cima, esquerda, baixo)
deltas = [(0,1),(-1,0),(0,-1),(1,0)]

def greedy_best_first(start, goal):
    open_heap = []
    tie = 0
    heappush(open_heap, (manhattan(start, goal), tie, start))
    tie += 1
    parent = {start: None}
    visited = set([start])
    expanded_order = []

    while open_heap:
        h, _, node = heappop(open_heap)
        expanded_order.append(node)
        if node == goal:
            break
        r,c = node
        for dr,dc in deltas:
            nr, nc = r+dr, c+dc
            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:
                neigh = (nr,nc)
                if neigh not in visited:
                    visited.add(neigh)
                    parent[neigh] = node
                    heappush(open_heap, (manhattan(neigh, goal), tie, neigh))
                    tie += 1

    # Reconstruir caminho
    path = []
    if goal in parent:
        cur = goal
        while cur is not None:
            path.append(cur)
            cur = parent.get(cur)
        path.reverse()
    return expanded_order, path

# Executar Guloso
expanded_order, path = greedy_best_first(start, goal)

# Plotar resultado
fig, ax = plt.subplots(figsize=(6,6))
ax.set_title("Busca Gulosa (h = Manhattan)\nNós expandidos (azul) e caminho (vermelho)")
ax.set_xlim(-0.5, cols-0.5)
ax.set_ylim(rows-0.5, -0.5)

# Grid
for r in range(rows):
    for c in range(cols):
        if grid[r][c] == 1:
            ax.add_patch(plt.Rectangle((c-0.5, r-0.5), 1, 1, color='black'))
        else:
            ax.add_patch(plt.Rectangle((c-0.5, r-0.5), 1, 1, color='white', edgecolor='gray'))

# Pintar nós expandidos
for idx, node in enumerate(expanded_order, start=1):
    r,c = node
    ax.add_patch(plt.Rectangle((c-0.5, r-0.5), 1, 1, color='skyblue'))
    ax.text(c, r, str(idx), va='center', ha='center', fontsize=7, color='black')

# Traçar caminho final
if path:
    xs = [c for (_,c) in path]
    ys = [r for (r,_) in path]
    ax.plot(xs, ys, linewidth=2, color='red')

# Marcar início e fim
ax.text(start[1], start[0], "I", va='center', ha='center', fontsize=12, fontweight='bold', color='blue')
ax.text(goal[1], goal[0], "F", va='center', ha='center', fontsize=12, fontweight='bold', color='red')

ax.set_xticks(range(cols))
ax.set_yticks(range(rows))
ax.grid(True)
plt.show()

# =========================
# Busca em Largura (BFS)
# =========================
from collections import deque

def bfs_search(start, goal):
    queue = deque([start])
    parent = {start: None}
    visited = set([start])
    expanded_order = []

    while queue:
        node = queue.popleft()
        expanded_order.append(node)
        if node == goal:
            break
        r, c = node
        for dr, dc in deltas:
            nr, nc = r+dr, c+dc
            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:
                neigh = (nr, nc)
                if neigh not in visited:
                    visited.add(neigh)
                    parent[neigh] = node
                    queue.append(neigh)

    # Reconstruir caminho
    path = []
    if goal in parent:
        cur = goal
        while cur is not None:
            path.append(cur)
            cur = parent.get(cur)
        path.reverse()
    return expanded_order, path


# =========================
# Busca em Profundidade (DFS)
# =========================
def dfs_search(start, goal):
    stack = [start]
    parent = {start: None}
    visited = set([start])
    expanded_order = []

    while stack:
        node = stack.pop()
        expanded_order.append(node)
        if node == goal:
            break
        r, c = node
        for dr, dc in deltas:
            nr, nc = r+dr, c+dc
            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:
                neigh = (nr, nc)
                if neigh not in visited:
                    visited.add(neigh)
                    parent[neigh] = node
                    stack.append(neigh)

    # Reconstruir caminho
    path = []
    if goal in parent:
        cur = goal
        while cur is not None:
            path.append(cur)
            cur = parent.get(cur)
        path.reverse()
    return expanded_order, path


# =========================
# Função para Plotar Resultado
# =========================
def plot_search_result(expanded_order, path, title):
    fig, ax = plt.subplots(figsize=(6,6))
    ax.set_title(title)
    ax.set_xlim(-0.5, cols-0.5)
    ax.set_ylim(rows-0.5, -0.5)

    # Grid
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 1:
                ax.add_patch(plt.Rectangle((c-0.5, r-0.5), 1, 1, color='black'))
            else:
                ax.add_patch(plt.Rectangle((c-0.5, r-0.5), 1, 1, color='white', edgecolor='gray'))

    # Pintar nós expandidos
    for idx, node in enumerate(expanded_order, start=1):
        r, c = node
        ax.add_patch(plt.Rectangle((c-0.5, r-0.5), 1, 1, color='skyblue'))
        ax.text(c, r, str(idx), va='center', ha='center', fontsize=7, color='black')

    # Traçar caminho final
    if path:
        xs = [c for (_, c) in path]
        ys = [r for (r, _) in path]
        ax.plot(xs, ys, linewidth=2, color='red')

    # Marcar início e fim
    ax.text(start[1], start[0], "I", va='center', ha='center', fontsize=12, fontweight='bold', color='blue')
    ax.text(goal[1], goal[0], "F", va='center', ha='center', fontsize=12, fontweight='bold', color='red')

    ax.set_xticks(range(cols))
    ax.set_yticks(range(rows))
    ax.grid(True)
    plt.show()


# =========================
# Executar e Plotar
# =========================
expanded_bfs, path_bfs = bfs_search(start, goal)
plot_search_result(expanded_bfs, path_bfs, "Busca em Largura (BFS)\nNós expandidos (azul) e caminho (vermelho)")

expanded_dfs, path_dfs = dfs_search(start, goal)
plot_search_result(expanded_dfs, path_dfs, "Busca em Profundidade (DFS)\nNós expandidos (azul) e caminho (vermelho)")